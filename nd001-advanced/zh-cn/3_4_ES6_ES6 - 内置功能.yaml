id: 374353
key: 1b997dce-e2ce-4246-b5ae-d39ca175f887
locale: zh-cn
version: 1.0.0
title: ES6 - 内置功能
semantic_type: Lesson
updated_at: 'Wed Sep 20 2017 09:09:49 GMT+0000 (UTC)'
is_public: true
image:
  url: 'https://d17h27t6h515a5.cloudfront.net/topher/2017/June/5935c832_3-2-setting-up-anaconda2x/3-2-setting-up-anaconda2x.jpg'
  width: 592
  height: 640
video: null
summary: JavaScript 环境默认地提供了各种功能。在这节课，我们将了解 Set、Map、Proxy、生成器以及迭代器的工作原理和更多知识！
lesson_type: Classroom
duration: 120
is_project_lesson: false
career_portal_experience_levels: []
_concepts_ids:
  - 374312
  - 374311
  - 374313
  - 374314
  - 374315
  - 374316
  - 374317
  - 374318
  - 374319
  - 374320
  - 374322
  - 374321
  - 374323
  - 374324
  - 374325
  - 374327
  - 374326
  - 374328
  - 374329
  - 374330
  - 374331
  - 374333
  - 374332
  - 374334
  - 374335
  - 374338
  - 374337
_project_id: null
concepts:
  - id: 374312
    key: 6efc26e1-d752-42a1-9184-04f73b6b4088
    locale: zh-cn
    version: 1.0.0
    title: 新的内置功能
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:32 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374195
    atoms:
      - id: 374195
        key: 94bcc833-83c8-48f5-ae10-6174a204fca9
        locale: zh-cn
        version: 1.0.0
        title: 新的内置功能
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:43:32 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43223'
          youtube_id: qfTkmFoLyfw
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/584229d9_01-intro/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/584229d9_01-intro/01-intro_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/584229d9_01-intro/01-intro_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/584229d9_01-intro/01-intro_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/584229d9_01-intro/01-intro_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/584229d9_01-intro/hls/playlist.m3u8'
  - id: 374311
    key: 1e3f0012-b247-4325-a5e7-c10651481f20
    locale: zh-cn
    version: 1.0.0
    title: Symbol 简介
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:33 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374196
    atoms:
      - id: 374196
        key: c4fc6ef2-d4fd-4049-af72-3001ae15fdd7
        locale: zh-cn
        version: 1.0.0
        title: Symbol 简介
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:43:33 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43139'
          youtube_id: kbVmzEQ4Hr0
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/583f7c62_02-symbols-intro/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c62_02-symbols-intro/02-symbols-intro_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c62_02-symbols-intro/02-symbols-intro_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c62_02-symbols-intro/02-symbols-intro_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c62_02-symbols-intro/02-symbols-intro_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c62_02-symbols-intro/hls/playlist.m3u8'
  - id: 374313
    key: 100b565f-0e61-42e9-a2f4-332aa2f1a1b6
    locale: zh-cn
    version: 1.0.0
    title: Symbol
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:34 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374197
      - 374198
    atoms:
      - id: 374197
        key: 85abe3e7-7937-4522-aaf1-46ec095b3ec9
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:34 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # Symbols（标识符）

          **Symbol** 是一种独特的且不可变的数据类型，经常用来标识对象属性。

          要创建 Symbol，输入 `Symbol()`，并添加一个可选的字符串作为其**描述**。

          ```js
          const sym1 = Symbol('apple');
          console.log(sym1);
          ```
          > `Symbol(apple)`

          它将创建唯一的标识符，并将其存储在 `sym1` 中。描述 `"apple"` 只是用来描述标识符的一种方式，但是不能用来访问标识符本身。

          为了展示它的工作原理，如果你对具有相同描述的两个标识符进行比较… 

          ```js
          const sym2 = Symbol('banana');
          const sym3 = Symbol('banana');
          console.log(sym2 === sym3);
          ```
          > `false`

          …结果是 `false`，因为描述只是用来描述符号，它并不是标识符本身的一部分。无论描述是什么，每次都创建新的标识符。
        instructor_notes: ''
        resources: null
      - id: 374198
        key: add1fba9-dbc4-49f4-89bc-4d5c8b53769a
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:34 GMT+0000 (UTC)'
        is_public: true
        text: |
          当然，依然很难弄明白，所以，我们来看一个之前视频中的示例，看看标识符的作用。下面是代表该示例中的 bowl 的代码。

          ```js
          const bowl = {
            'apple': { color: 'red', weight: 136.078 },
            'banana': { color: 'yellow', weight: 183.15 },
            'orange': { color: 'orange', weight: 170.097 }
          };
          ```

          bowl 中包含水果，它们是碗的属性对象。但是，当我们添加第二个香蕉时，遇到了问题。

          ```js
          const bowl = {
            'apple': { color: 'red', weight: 136.078 },
            'banana': { color: 'yellow', weight: 183.151 },
            'orange': { color: 'orange', weight: 170.097 },
            'banana': { color: 'yellow', weight: 176.845 }
          };
          console.log(bowl);
          ```
          > `Object {apple: Object, banana: Object, orange: Object}`

          新添加的香蕉将上一个香蕉覆盖了。为了解决该问题，我们可以使用标识符。

          ```js
          const bowl = {
            [Symbol('apple')]: { color: 'red', weight: 136.078 },
            [Symbol('banana')]: { color: 'yellow', weight: 183.15 },
            [Symbol('orange')]: { color: 'orange', weight: 170.097 },
            [Symbol('banana')]: { color: 'yellow', weight: 176.845 }
          };
          console.log(bowl);
          ```
          > `Object {Symbol(apple): Object, Symbol(banana): Object, Symbol(orange): Object, Symbol(banana): Object}`

          通过更改 bowl 的属性并使用标识符，每个属性都是唯一的标识符，第一个香蕉不会被第二个香蕉覆盖。
        instructor_notes: ''
        resources: null
  - id: 374314
    key: 966cea8f-5583-4d46-80ef-ed4c829c63c7
    locale: zh-cn
    version: 1.0.0
    title: 迭代器协议和可迭代协议
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:43 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374199
      - 374200
    atoms:
      - id: 374199
        key: 9c22771b-3a5c-42e7-9bb6-3cf1a4cb2196
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Tue Sep 19 2017 15:51:34 GMT+0000 (UTC)'
        is_public: true
        text: |
          在继续之前，我们先花些时间看一下 ES6 中的两个新协议：

          * **可迭代**协议
          * **迭代器**协议

          这些协议不是内置的，但是它们可以帮助你理解 ES6 中的新迭代概念，就像给你展示标识符的使用案例一样。

          # 可迭代协议

          **可迭代协议**用来定义和自定义对象的迭代行为。也就是说在 ES6 中，你可以灵活地指定循环访问对象中的值的方式。对于某些对象，它们已经内置了这一行为。例如，字符串和数组就是内置可迭代类型的例子。

          ```js
          const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
          for (const digit of digits) {
            console.log(digit);
          }
          ```
          > 0 <br>
          > 1 <br>
          > 2 <br>
          > 3 <br>
          > 4 <br>
          > 5 <br>
          > 6 <br>
          > 7 <br>
          > 8 <br>
          > 9 <br>

          在第一节课，我们提到，任何可迭代的对象都可以使用新的 `for...of` 循环。在这节课的稍后阶段，我们还将学习 Set 和 Map，它们也是内置可迭代类型。

          ## 工作原理

          为了使对象可迭代，它必须实现**可迭代接口**。如果你之前使用的是 Java 或 C 语言等语言，那么你可能熟悉接口，但是如果没用过这些语言，接口其实就是为了让对象可迭代，它必须包含默认的迭代器方法。该方法将定义对象如何被迭代。

          **迭代器方法**（可通过常量 `[Symbol.iterator]` 获得）是一个无参数的函数，返回的是迭代器对象。迭代器对象是遵守迭代器协议的对象。

          # 迭代器协议

          **迭代器协议**用来定义对象生成一系列值的标准方式。实际上就是现在有了定义对象如何迭代的流程。通过执行 `.next()` 方法来完成这一流程。

          ## 工作原理

          当对象执行 `.next()` 方法时，就变成了迭代器。`.next()` 方法是无参数函数，返回具有两个属性的对象：

          1. `value`：表示对象内值序列的下个值的数据
          2. `done`：表示迭代器是否已循环访问完值序列的布尔值
            * 如果 done 为 _true_，则迭代器已到达值序列的末尾处。
            * 如果 done 为 _false_，则迭代器能够生成值序列中的另一个值。

          下面是之前的一个示例，但是我们改为使用数组的默认迭代器访问数组中的每个值。

          ```js
          const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
          const arrayIterator = digits[Symbol.iterator]();

          console.log(arrayIterator.next());
          console.log(arrayIterator.next());
          console.log(arrayIterator.next());
          ```
          > ```js
          Object {value: 0, done: false}
          Object {value: 1, done: false}
          Object {value: 2, done: false}
          ```
        instructor_notes: ''
        resources: null
      - id: 374200
        key: f8630634-ab9d-4d02-84d6-2182f0b38d26
        locale: zh-cn
        version: 1.0.0
        title: ''
        semantic_type: QuizAtom
        updated_at: 'Tue Sep 19 2017 15:51:45 GMT+0000 (UTC)'
        is_public: true
        resources: null
        instructor_notes: ''
        instruction: null
        question:
          title: ''
          semantic_type: ProgrammingQuestion
          evaluation_id: '5615841350647808'
          evaluator:
            model: ProgramEvaluator
            execution_language: python
            executor_grading_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'submit'])
            executor_test_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'test'])
            gae_grading_code: |-
              """Provide feedback to student based on evaluation of JavaScript programming quiz."""

              import json

              # until we check, assume student's submission is incorrect
              grade_result['correct'] = False

              # don't use, but must set to ' ' to avoid error
              grade_result['comment'] = ' '

              # use default markdown?
              use_default_markdown = True

              def parse_swizzled_output(output):
                  """Analyzes the swizzled output for passing/failing criteria and other feedback.
                      
                      Args:
                      output (string): Output generated when running swizzled main.
                      """
                  # keep running total of (passed) criteria
                  numberOfCriteria = 0
                  numberOfPasses = 0
                  passed_criteria = []
                  failed_criteria = []
                  feedback = []
                  # split lines by newline
                  lines = output.split('\n')
                  # go line-by-line and find formatted tags for criteria
                  for line in lines:
                      if line.startswith('<PASS::>'):
                          numberOfCriteria += 1
                          numberOfPasses += 1
                          # strip tag and add criteria to array
                          passed_criteria.append(line[8:])
                      if line.startswith('<FAIL::>'):
                          numberOfCriteria += 1
                          # strip tag and add criteria to array
                          failed_criteria.append(line[8:])
                      if line.startswith('<FEEDBACK::>'):
                          # strip tag and add feedback to array
                          feedback.append(line[12:])
                  # return results
                  return (numberOfCriteria == numberOfPasses, passed_criteria, failed_criteria, feedback)

              def default_markdown_from_criteria(passing_criteria, failing_criteria):
                  """Generates default markdown-like string based on passing/failing criteria.

                      Args:
                      passing_criteria (list): All passing criteria from quiz
                      failing_criteria (list): All failing criteria from quiz
                      """
                  # init markdown-like string
                  markdown = ''
                  # was there more than 1 criteria?
                  if passing_criteria + failing_criteria > 1:
                      # add passing criteria to markdown
                      if len(passing_criteria) >= 1:
                          markdown += '# What Went Well\n\n'
                          for criteria in passing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                      # add failing criteria to markdown
                      if len(failing_criteria) >= 1:
                          markdown += '# What Went Wrong\n\n'
                          for criteria in failing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                  else:
                      # if only 1 criteria, add it without headers to markdown
                      markdown = passing_criteria[0] if grade_result['correct'] else failing_criteria[0]
                  # return markdown-like string
                  return markdown

              def main():
                  """Analyze the output generated by Falcon and set special key/value pairs for feedback."""
                  # did the remote execution cause an error?
                  if executor_result['stderr'] == '':
                      # nope! analyze the output (JSON-like string)
                      try:
                          # convert JSON-like string into Python dictionary
                          results = json.loads(executor_result['stdout'])
                          swizzle_out = results['temp/results-out.txt']
                      except Exception as e:
                          # if there was an error during the conversion, display it
                          grade_result['feedback'] = executor_result['stderr']
                      else:
                          # did the execution of swizzled main produce an error?
                          if results['temp/results-err.txt'] == '':
                              # nope! we can safely use the output of swizzled main
                              (submission_correct, passing_criteria, failing_criteria, feedback) = parse_swizzled_output(swizzle_out)
                              # set pass/fail
                              grade_result['correct'] = submission_correct
                              if use_default_markdown == True:
                                  # use default markdown for criteria/feedback
                                  markdown_feedback = default_markdown_from_criteria(passing_criteria, failing_criteria)
                                  total_criteria = len(failing_criteria) + len(passing_criteria)
                                  all_feedback = markdown_feedback + '# Feedback\n\n'
                                  if len(failing_criteria) == 0:
                                      all_feedback += 'Your answer passed all our tests! Awesome job!'
                                  elif len(passing_criteria) >= total_criteria / 2:
                                      all_feedback += 'Not everything is correct yet, but you\'re close!'
                                  else:
                                      all_feedback += 'There\'s work left to do. Try tackling one problem at a time.'
                                  grade_result['feedback'] = all_feedback
                                  # grade_result['comment'] = results['temp/student-out.txt']
                              else:
                                  # show raw response from REX execution
                                  grade_result['feedback'] = str(results)
                          else:
                              # swizzled main generated some an error, so display it!
                              grade_result['feedback'] = 'An error occurred while testing your code.\n\nCheck to ensure these items are true:\n\n- clicking **TEST RUN** doesn\'t produce any issues\n- you\'ve followed all instructions\n- you\'ve used the correct names\n\nIf you make all these checks, but it still doesn\'t fix the error, then please contact us at *support@udacity.com* and provide a link to the quiz and a copy of your code.\n\nNOTE: If you cannot find the instructions, click **RESET QUIZ** to reset the quiz to its original state.'
                  else:
                      # there was an error with overall execution, so display it!
                      grade_result['comment'] = executor_result['stderr']

              main()
            requires_gpu: false
            deadline_seconds: 0
            legacy_template_refs:
              - key: '5141761099956224'
                ref: ProgramTemplate
            included_text_files:
              - text: |
                  /* eslint no-unused-vars: "off" */

                  var logBackup = console.log;
                  var logMessages = [];

                  console.log = function () {
                      logMessages.push.apply(logMessages, arguments);
                      logBackup.apply(console, arguments);
                  };

                  function getASTMatches(esquery, tree, selector) {
                      var result = esquery.parse(selector);
                      return esquery.match(tree, result);
                  }

                  function bodyElementIsNotEmpty(body) {
                      return body[0].body.length !== 0;
                  }
                name: SwizzleBefore.js
              - text: |
                  /* eslint-env es6 */
                  /* global getASTMatches, bodyElementIsNotEmpty, james */

                  (function () {
                      const assert = require('chai').assert;
                      const esprima = require('esprima');
                      const esquery = require('esquery');
                      const content = require('fs').readFileSync(__dirname + '/StudentMain.js', 'utf8');

                      const AST = esprima.parse(content);
                      const body = getASTMatches(esquery, AST, '[body]');

                      if (bodyElementIsNotEmpty(body)) {
                          describe('The `james` object', function () {
                              it('should have a `Symbol.iterator` method', function () {
                                  assert.property(james, Symbol.iterator, 'You need to add a `Symbol.iterator` method');
                              });

                              it('should create an iterator', function () {
                                  const iterator = james[Symbol.iterator]();

                                  assert.property(iterator, 'next', "Calling `james[Symbol.iterator]()` doesn't produce an object with a `.next()` method.");
                              });
                          });

                          describe('Your code', function () {
                              it('should produce the expected result', function () {
                                  const iterator = james[Symbol.iterator]();
                                  const actual1 = iterator.next();
                                  const actual2 = iterator.next();
                                  const actual3 = iterator.next();
                                  const expected1 = { value: 'James', key: 'name', done: false };
                                  const expected2 = { value: `5'10"`, key: 'height', done: false };
                                  const expected3 = { value: 185, key: 'weight', done: true };

                                  assert.deepEqual(actual1, expected1, `The first call to \`iterator.next()\` should print ${JSON.stringify(expected1)}, but saw ${JSON.stringify(actual1)}`);
                                  assert.deepEqual(actual2, expected2, `The second call to \`iterator.next()\` should print ${JSON.stringify(expected2)}, but saw ${JSON.stringify(actual2)}`);
                                  assert.deepEqual(actual3, expected3, `The third call to \`iterator.next()\` should print ${JSON.stringify(expected3)}, but saw ${JSON.stringify(actual3)}`);
                              });
                          });
                      } else {
                          describe('Your code', function () {
                              it('should not be empty', function () {
                                  assert.isOk(false, 'Your code is missing, hit the "Reset Quiz" button to reset the quiz');
                              });
                          });
                      }

                  }());
                name: SwizzleAfter.js
        answer: null
  - id: 374315
    key: 2f7b76c6-d4a1-4168-98e4-662a17c3dd53
    locale: zh-cn
    version: 1.0.0
    title: Set
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:44 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374201
      - 374203
      - 374202
    atoms:
      - id: 374201
        key: 58ba210b-0f56-4f3b-ad1b-ae03b1ffc86b
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:43 GMT+0000 (UTC)'
        is_public: true
        text: |
          # 数学意义上的集合

          回忆下之前的数学知识，Set 就是唯一项的集合。例如，`{2, 4, 5, 6}` 是 Set，因为每个数字都是唯一的，只出现一次。但是，`{1, 1, 2, 4}` 不是 Set，因为它_包含重复的项目_（1 出现了两次！）。

          在 JavaScript 中，我们已经可以使用数组表示类似于数学意义上的集合。

          ```js
          const nums = [2, 4, 5, 6];
          ```

          但是，数组并不要求项目必须唯一。如果我们尝试向 `nums` 中添加一个 `2`，JavaScript 不会报错，会正常添加这个 `2`。

          ```js
          nums.push(2);
          console.log(nums);
          ```
          > `[2, 4, 5, 6, 2]`

          现在，`nums` 不再是数学意义上的集合。
        instructor_notes: ''
        resources: null
      - id: 374203
        key: f7ced6ec-92a5-44ee-982a-1364c7c823f8
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:44 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # Set（集合）

          在 ES6 中，有一个新的内置对象的行为和数学意义上的集合相同，使用起来类似于数组。这个新对象就叫做“Set”。Set 与 array 之间的最大区别是：

          * Set 不基于索引，不能根据集合中的条目在集合中的位置引用这些条目
          * Set 中的条目不能单独被访问

          基本上，Set 是让你可以存储唯一条目的对象。你可以向 Set 中添加条目，删除条目，并循环访问 Set。这些条目可以是原始值或对象。

          ## 如何创建一个 Set

          可以通过几种不同的方式创建 Set。第一种很简单：

          ```js
          const games = new Set();
          console.log(games);
          ```
          > `Set {}`

          此代码会创建空的 Set `games`，其中没有条目。

          如果你想根据值列表创建 Set，则使用数组：

          ```js
          const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
          console.log(games);
          ```
          > `Set {'Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart'}`

          注意上述示例在创建 Set 时，会自动移除重复的条目 `"Super Mario Bros."`，很整洁！
        instructor_notes: ''
        resources: null
      - id: 374202
        key: b473de9c-52e1-4098-afc2-7e7fdfb4cde8
        locale: zh-cn
        version: 1.0.0
        title: Set 唯一性
        semantic_type: CheckboxQuizAtom
        updated_at: 'Mon Sep 11 2017 16:43:44 GMT+0000 (UTC)'
        is_public: true
        question:
          prompt: 下面的哪些集合代表的是 JavaScript 中的 Set。
          correct_feedback: 很棒！你所选择的选项代表了 Set，因为它们里面的条目都是唯一的。
          video_feedback: null
          default_feedback: Set 是没有重复值的对象。其他哪些对象也没有重复值？
          answers:
            - id: a1484355919814
              text: '`{1, ''Basketball'', true, false, ''1''}`'
              is_correct: true
              incorrect_feedback: ''
            - id: a1484355942292
              text: '`{}`'
              is_correct: true
              incorrect_feedback: ''
            - id: a1484355950153
              text: '`{1, 1, 1, 1}`'
              is_correct: false
              incorrect_feedback: ''
            - id: a1484355956904
              text: '`{false, ''0'', 0, ''Soccer'', 3.14, 25, 0}`'
              is_correct: false
              incorrect_feedback: ''
            - id: a1484355964353
              text: '`{''Gymnastics'', ''Swimming'', 2}`'
              is_correct: true
              incorrect_feedback: ''
  - id: 374316
    key: 0396aaa7-ccc8-49b5-93ad-725c2f61f889
    locale: zh-cn
    version: 1.0.0
    title: 修改 Set
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:45 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374204
      - 374205
    atoms:
      - id: 374204
        key: b9764f7f-22a7-4ad3-a8d5-6024eda50cc0
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:44 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 修改 Set

          创建 Set 后，你可能想要添加或删除条目。如何操作呢？可以使用名称对应的 `.add()` 和 `.delete()` 方法：

          ```js
          const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);

          games.add('Banjo-Tooie');
          games.add('Age of Empires');
          games.delete('Super Mario Bros.');

          console.log(games);
          ```
          > `Set {'Banjo-Kazooie', 'Mario Kart', 'Banjo-Tooie', 'Age of Empires'}`

          另一方面，如果你想要删除 Set 中的所有条目，可以使用 `.clear()` 方法。

          ```js
          games.clear()
          console.log(games);
          ```
          > `Set {}`
        instructor_notes: ''
        resources: null
      - id: 374205
        key: d432d46b-8238-424a-ba4f-d18dfacda17d
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:45 GMT+0000 (UTC)'
        is_public: true
        text: '> **提示**：如果你尝试向 Set 中 `.add()` 重复的条目，系统不会报错，但是该条目不会添加到 Set 中。此外，如果你尝试 `.delete()` Set 中不存在的条目，也不会报错，Set 保持不变。如果成功地添加或删除了条目，这两个方法都返回 `true`，反之返回 `false`。'
        instructor_notes: ''
        resources: null
  - id: 374317
    key: 50d51cb3-016f-432d-9de0-9f3b9b32f006
    locale: zh-cn
    version: 1.0.0
    title: 使用 Set
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:46 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374206
      - 374207
    atoms:
      - id: 374206
        key: 8e1e3910-21b4-47fc-82f5-790d30b48478
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:45 GMT+0000 (UTC)'
        is_public: true
        text: |
          ## 使用 Set

          ### 查看长度
          构建 Set 后，可以通过几个不同的属性和方法来处理 Set。

          使用 `.size` 属性可以返回 Set 中的条目数：

          ```js
          const months = new Set(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);
          console.log(months.size);
          ```
          > `12`

          注意，不能像数组那样通过索引访问 Set，因此要使用 `.size` 属性，而不是 `.length` 属性来获取 Set 的大小。

          ### 检查是否存在某个条目
          使用 `.has()` 方法可以检查 Set 中是否存在某个条目。如果 Set 中有该条目，则 `.has()` 将返回 `true`。如果 Set 中不存在该条目，则 `.has()` 将返回 `false`。

          ```js
          console.log(months.has('September'));
          ```
          > `true`

          ### 检索所有值
          最后，使用 `.values()` 方法可以返回 Set 中的值。`.values()` 方法的返回值是 `SetIterator` 对象。

          ```js
          console.log(months.values());
          ```
          > `SetIterator {'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'}`

          稍后将讲解 `SetIterator` 对象！
        instructor_notes: ''
        resources: null
      - id: 374207
        key: c6c67475-5e42-4ea7-98c5-b8626e786872
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:46 GMT+0000 (UTC)'
        is_public: true
        text: '> **提示**：`.keys()` 方法将和 `.values()` 方法的行为完全一样：将 Set 的值返回到新的迭代器对象中。`.keys()` 方法是 `.values()` 方法的别名，和 Map（映射）中的类似。你稍后将在这节课的 Map 部分看到 `.keys()` 方法。'
        instructor_notes: ''
        resources: null
  - id: 374318
    key: 32a8b076-b891-4993-9e47-648b9f7485c0
    locale: zh-cn
    version: 1.0.0
    title: Set 与迭代器
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:47 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374208
      - 374209
      - 374210
    atoms:
      - id: 374208
        key: 3ff30bf8-0e91-4463-ade7-fa0849a5d8dd
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:46 GMT+0000 (UTC)'
        is_public: true
        text: |-
          处理 Set 的最后一步是循环访问 Set。

          如果还记得之前介绍的 ES6 中的新可迭代协议和迭代器协议，那么你会想起 Set 是内置可迭代类型。这意味着循环时的两件事：

          1. 你可以使用 Set 的默认迭代器循环访问 Set 中的每一项。
          2. 你可以使用新的 `for...of` 循环来循环访问 Set 中的每一项。

          ## 使用 SetIterator

          因为 `.values()` 方法返回新的迭代器对象（称为 `SetIterator`），你可以将该迭代器对象存储在变量中，并使用 `.next()` 访问 Set 中的每一项。

          ```js
          const iterator = months.values();
          iterator.next();
          ```
          > `Object {value: 'January', done: false}`

          如果再次运行 `.next()` 呢？

          ```js
          iterator.next();
          ```
          > `Object {value: 'February', done: false}`

          一直运行到 `done` 等于 `true` 时，标志着 Set 的结束。
        instructor_notes: ''
        resources: null
      - id: 374209
        key: 3bd264cf-5967-461a-b394-186371840ca6
        locale: zh-cn
        version: 1.0.0
        title: Set 和迭代器的动画
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:43:46 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '54438'
          youtube_id: Hd205fgC7qo
          subtitles: []
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011dfa_ud356-l3-sets-and-iterators-animation/ud356-l3-sets-and-iterators-animation_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011dfa_ud356-l3-sets-and-iterators-animation/ud356-l3-sets-and-iterators-animation_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011dfa_ud356-l3-sets-and-iterators-animation/ud356-l3-sets-and-iterators-animation_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011dfa_ud356-l3-sets-and-iterators-animation/ud356-l3-sets-and-iterators-animation_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011dfa_ud356-l3-sets-and-iterators-animation/hls/playlist.m3u8'
      - id: 374210
        key: 0b40a6b3-46a6-4ce4-8ccf-9c78e8f7378b
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:47 GMT+0000 (UTC)'
        is_public: true
        text: |
          ## 使用 `for...of` 循环

          一种更简单的方法去循环访问 Set 中的项目是 `for...of` 循环。

          ```js
          const colors = new Set(['red', 'orange', 'yellow', 'green', 'blue', 'violet', 'brown', 'black']);
          for (const color of colors) {
            console.log(color);
          }
          ```
          > red <br>
          > orange <br>
          > yellow <br>
          > green <br>
          > blue <br>
          > violet <br>
          > brown <br>
          > black
        instructor_notes: ''
        resources: null
  - id: 374319
    key: 98ba5617-7451-4f82-847a-cf407c35150c
    locale: zh-cn
    version: 1.0.0
    title: 练习：使用 Set
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:50 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374211
      - 374212
    atoms:
      - id: 374211
        key: 47e86266-5d89-43a2-aa19-dc62ea906430
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:47 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 指导说明：

          创建一个名称为 `myFavoriteFlavors` 的变量，并将其值设为空的 `Set` 对象。然后使用 `.add()` 方法向其中添加以下字符串：

          * "chocolate chip"
          * "cookies and cream"
          * "strawberry"
          * "vanilla"

          然后使用 `.delete()` 方法移除 Set 中的 "strawberry"。

          ## 你的代码：
        instructor_notes: ''
        resources: null
      - id: 374212
        key: 0630be03-0b91-4024-b9b8-3c3a6bde89ce
        locale: zh-cn
        version: 1.0.0
        title: ''
        semantic_type: QuizAtom
        updated_at: 'Mon Sep 11 2017 16:43:49 GMT+0000 (UTC)'
        is_public: true
        resources: null
        instructor_notes: ''
        instruction: null
        question:
          title: ''
          semantic_type: ProgrammingQuestion
          evaluation_id: '4901671546257408'
          evaluator:
            model: ProgramEvaluator
            execution_language: python
            executor_grading_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'submit'])
            executor_test_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'test'])
            gae_grading_code: |-
              """Provide feedback to student based on evaluation of JavaScript programming quiz."""

              import json

              # until we check, assume student's submission is incorrect
              grade_result['correct'] = False

              # don't use, but must set to ' ' to avoid error
              grade_result['comment'] = ' '

              # use default markdown?
              use_default_markdown = True

              def parse_swizzled_output(output):
                  """Analyzes the swizzled output for passing/failing criteria and other feedback.
                      
                      Args:
                      output (string): Output generated when running swizzled main.
                      """
                  # keep running total of (passed) criteria
                  numberOfCriteria = 0
                  numberOfPasses = 0
                  passed_criteria = []
                  failed_criteria = []
                  feedback = []
                  # split lines by newline
                  lines = output.split('\n')
                  # go line-by-line and find formatted tags for criteria
                  for line in lines:
                      if line.startswith('<PASS::>'):
                          numberOfCriteria += 1
                          numberOfPasses += 1
                          # strip tag and add criteria to array
                          passed_criteria.append(line[8:])
                      if line.startswith('<FAIL::>'):
                          numberOfCriteria += 1
                          # strip tag and add criteria to array
                          failed_criteria.append(line[8:])
                      if line.startswith('<FEEDBACK::>'):
                          # strip tag and add feedback to array
                          feedback.append(line[12:])
                  # return results
                  return (numberOfCriteria == numberOfPasses, passed_criteria, failed_criteria, feedback)

              def default_markdown_from_criteria(passing_criteria, failing_criteria):
                  """Generates default markdown-like string based on passing/failing criteria.

                      Args:
                      passing_criteria (list): All passing criteria from quiz
                      failing_criteria (list): All failing criteria from quiz
                      """
                  # init markdown-like string
                  markdown = ''
                  # was there more than 1 criteria?
                  if passing_criteria + failing_criteria > 1:
                      # add passing criteria to markdown
                      if len(passing_criteria) >= 1:
                          markdown += '# What Went Well\n\n'
                          for criteria in passing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                      # add failing criteria to markdown
                      if len(failing_criteria) >= 1:
                          markdown += '# What Went Wrong\n\n'
                          for criteria in failing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                  else:
                      # if only 1 criteria, add it without headers to markdown
                      markdown = passing_criteria[0] if grade_result['correct'] else failing_criteria[0]
                  # return markdown-like string
                  return markdown

              def main():
                  """Analyze the output generated by Falcon and set special key/value pairs for feedback."""
                  # did the remote execution cause an error?
                  if executor_result['stderr'] == '':
                      # nope! analyze the output (JSON-like string)
                      try:
                          # convert JSON-like string into Python dictionary
                          results = json.loads(executor_result['stdout'])
                          swizzle_out = results['temp/results-out.txt']
                      except Exception as e:
                          # if there was an error during the conversion, display it
                          grade_result['feedback'] = executor_result['stderr']
                      else:
                          # did the execution of swizzled main produce an error?
                          if results['temp/results-err.txt'] == '':
                              # nope! we can safely use the output of swizzled main
                              (submission_correct, passing_criteria, failing_criteria, feedback) = parse_swizzled_output(swizzle_out)
                              # set pass/fail
                              grade_result['correct'] = submission_correct
                              if use_default_markdown == True:
                                  # use default markdown for criteria/feedback
                                  markdown_feedback = default_markdown_from_criteria(passing_criteria, failing_criteria)
                                  total_criteria = len(failing_criteria) + len(passing_criteria)
                                  all_feedback = markdown_feedback + '# Feedback\n\n'
                                  if len(failing_criteria) == 0:
                                      all_feedback += 'Your answer passed all our tests! Awesome job!'
                                  elif len(passing_criteria) >= total_criteria / 2:
                                      all_feedback += 'Not everything is correct yet, but you\'re close!'
                                  else:
                                      all_feedback += 'There\'s work left to do. Try tackling one problem at a time.'
                                  grade_result['feedback'] = all_feedback
                                  # grade_result['comment'] = results['temp/student-out.txt']
                              else:
                                  # show raw response from REX execution
                                  grade_result['feedback'] = str(results)
                          else:
                              # swizzled main generated some an error, so display it!
                              grade_result['feedback'] = 'An error occurred while testing your code.\n\nCheck to ensure these items are true:\n\n- clicking **TEST RUN** doesn\'t produce any issues\n- you\'ve followed all instructions\n- you\'ve used the correct names\n\nIf you make all these checks, but it still doesn\'t fix the error, then please contact us at *support@udacity.com* and provide a link to the quiz and a copy of your code.\n\nNOTE: If you cannot find the instructions, click **RESET QUIZ** to reset the quiz to its original state.'
                  else:
                      # there was an error with overall execution, so display it!
                      grade_result['comment'] = executor_result['stderr']

              main()
            requires_gpu: false
            deadline_seconds: 0
            legacy_template_refs:
              - key: '5141761099956224'
                ref: ProgramTemplate
            included_text_files:
              - text: |
                  /* eslint no-unused-vars: "off" */

                  function getASTMatches(esquery, tree, selector) {
                      var result = esquery.parse(selector);
                      return esquery.match(tree, result);
                  }

                  function bodyElementIsNotEmpty(body) {
                      return body[0].body.length !== 0;
                  }
                name: SwizzleBefore.js
              - text: |
                  /* global getASTMatches, bodyElementIsNotEmpty, myFavoriteFlavors */

                  ;(function () { // eslint-disable-line no-extra-semi
                      const assert = require('chai').assert;
                      const esprima = require('esprima');
                      const esquery = require('esquery');
                      const content = require('fs').readFileSync(__dirname + '/StudentMain.js', 'utf8');

                      const AST = esprima.parse(content);
                      const body = getASTMatches(esquery, AST, '[body]');

                      if (bodyElementIsNotEmpty(body)) {
                          describe('Your code', function () {
                              it('should have a variable `myFavoriteFlavors`', function () {
                                  assert.isDefined(myFavoriteFlavors, 'You need to define the `myFavoriteFlavors` variable');
                              });

                              it('should use the `.add()` method to add required items to the set', function () {
                                  const callsToAddMethod = getASTMatches(esquery, AST, 'CallExpression [name="add"]');

                                  assert.equal(callsToAddMethod.length, 4, 'You did not use `.add()` the correct number of times.');
                              });

                              const callToDeleteMethod = getASTMatches(esquery, AST, 'ExpressionStatement [callee.property.name="delete"]');
                              it('should use the `.delete()` method to remove "strawberry"', function () {
                                  const [deleteObj] = callToDeleteMethod;

                                  assert.equal(deleteObj.arguments[0].value, 'strawberry', 'You should use `.delete()` to remove "strawberry"');
                              });

                              it('should use the `.delete()` method only once', function () {
                                  assert.equal(callToDeleteMethod.length, 1, 'You should only use the `.delete()` method once.');
                              });
                          });

                          describe('The `myFavoriteFlavors` object', function () {
                              it('should contain "chocolate chip"', function () {
                                  assert.isTrue(myFavoriteFlavors.has('chocolate chip'), '`myFavoriteFlavors` should contain "chocolate chip"');
                              });

                              it('should contain "cookies and cream"', function () {
                                  assert.isTrue(myFavoriteFlavors.has('cookies and cream'), '`myFavoriteFlavors` should contain "cookies and cream"');
                              });

                              it('should contain "vanilla"', function () {
                                  assert.isTrue(myFavoriteFlavors.has('vanilla'), '`myFavoriteFlavors` should contain "vanilla"');
                              });

                              it('should not contain "strawberry"', function () {
                                  assert.isFalse(myFavoriteFlavors.has('strawberry'), '`myFavoriteFlavors` should not contain "strawberry"');
                              });
                          });
                      } else {
                          describe('Your code', function () {
                              it('should not be empty', function () {
                                  assert.isOk(false, 'Your code is missing, hit the "Reset Quiz" button to reset the quiz');
                              });
                          });
                      }

                  }());
                name: SwizzleAfter.js
        answer: null
  - id: 374320
    key: 5c3fd7d7-66b4-4a9c-b61d-33dd85b8cc0e
    locale: zh-cn
    version: 1.0.0
    title: WeakSet
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:52 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374213
      - 374214
      - 374215
      - 374216
    atoms:
      - id: 374213
        key: 04f4319d-9fda-448e-9d2c-0d67b49e7535
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:51 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # 什么是 WeakSet（弱集合）？

          WeakSet 和普通 Set 很像，但是具有以下关键区别：

          1. WeakSet 只能包含对象
          2. WeakSet 无法迭代，意味着不能循环访问其中的对象
          3. WeakSet 没有 `.clear()` 方法

          你可以像创建普通 Set 那样创建 WeakSet，但是需要使用 `WeakSet` 构造函数。

          ```js
          const student1 = { name: 'James', age: 26, gender: 'male' };
          const student2 = { name: 'Julia', age: 27, gender: 'female' };
          const student3 = { name: 'Richard', age: 31, gender: 'male' };

          const roster = new WeakSet([student1, student2, student3]);
          console.log(roster);
          ```
          > `WeakSet {Object {name: 'Julia', age: 27, gender: 'female'}, Object {name: 'Richard', age: 31, gender: 'male'}, Object {name: 'James', age: 26, gender: 'male'}}`

          但是如果你尝试添加对象以外的内容，系统将报错！

          ```js
          roster.add('Amanda');
          ```
          > `Uncaught TypeError: Invalid value used in weak set(…)`

          这是预期到的行为，因为 WeakSet 只能包含对象。但是为何只能包含对象？如果普通 Set 可以包含对象和其他类型的数据，为何还要使用 WeakSet？这个问题的答案与为何 WeakSet 没有 `.clear()` 方法有很大的关系……
        instructor_notes: ''
        resources: null
      - id: 374214
        key: d9047af6-b408-426a-932c-457b0bf26ad7
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:51 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 垃圾回收

          在 JavaScript 中，创建新的值时会分配内存，并且当这些值不再需要时，将自动释放内存。这种内存不再需要后释放内存的过程称为**垃圾回收**。

          WeakSet 通过专门使用对象作为键值来利用这一点。如果将对象设为 `null`，则本质上是删除该对象。当 JavaScript 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。

          ```js
          student3 = null;
          console.log(roster);
          ```
          > `WeakSet {Object {name: 'Julia', age: 27, gender: 'female'}, Object {name: 'James', age: 26, gender: 'male'}}`
        instructor_notes: ''
        resources: null
      - id: 374215
        key: 7c674835-62e2-4a41-acc6-36a5f5b2d04f
        locale: zh-cn
        version: 1.0.0
        title: WeakSet 动画
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:43:51 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: |+

        resources: null
        video:
          id: '54435'
          youtube_id: Z0t-ZaR38ME
          subtitles: []
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011aea_ud356-l3-weaksets-animation/ud356-l3-weaksets-animation_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011aea_ud356-l3-weaksets-animation/ud356-l3-weaksets-animation_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011aea_ud356-l3-weaksets-animation/ud356-l3-weaksets-animation_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011aea_ud356-l3-weaksets-animation/ud356-l3-weaksets-animation_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011aea_ud356-l3-weaksets-animation/hls/playlist.m3u8'
      - id: 374216
        key: 60f214e0-a466-41d0-930b-c3e322bc3717
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:52 GMT+0000 (UTC)'
        is_public: true
        text: |-
          这种机制的好处在于你不用去担心要删掉对 WeakSet 中已删除对象的引用，JavaScript 会帮你删除！如果对象被删除，当垃圾回收器运行时，该对象也会从 WeakSet 中删除。这样的话，如果你想要一种高效、轻便的解决方法去创建一组对象，就可以使用 WeakSet。

          垃圾回收的发生时间点取决于很多因素。请参阅 [MDN 的文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Garbage_collection)，详细了解用于处理 JavaScript 中的垃圾回收的算法。
        instructor_notes: ''
        resources: null
  - id: 374322
    key: 17d90bf6-2ce7-45df-8f61-2a50da1b0123
    locale: zh-cn
    version: 1.0.0
    title: 练习：使用 WeakSet
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:56 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374217
      - 374218
    atoms:
      - id: 374217
        key: 911639c9-eb7c-4cb9-b3d5-7feb6c659e79
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:52 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 指导说明：

          创建以下变量：

          * `uniqueFlavors`，将其值设为空的 `WeakSet` 对象
          * `flavor1`，将其设为对象 `{ flavor: 'chocolate' }`
          * `flavor2`，将其设为一个对象，该对象的属性为 `flavor`，值可以自己选择

          使用 `.add()` 方法将对象 `flavor1` 和 `flavor2` 添加到 `uniqueFlavors`。

          使用 `.add()` 方法再次将 `flavor1` 对象添加到 `uniqueFlavors` Set。

          ## 你的代码：
        instructor_notes: ''
        resources: null
      - id: 374218
        key: 6f12039b-d0ca-4df5-abfc-7d27b0151f4b
        locale: zh-cn
        version: 1.0.0
        title: ''
        semantic_type: QuizAtom
        updated_at: 'Mon Sep 11 2017 16:43:55 GMT+0000 (UTC)'
        is_public: true
        resources: null
        instructor_notes: ''
        instruction: null
        question:
          title: ''
          semantic_type: ProgrammingQuestion
          evaluation_id: '6432334028079104'
          evaluator:
            model: ProgramEvaluator
            execution_language: python
            executor_grading_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'submit'])
            executor_test_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'test'])
            gae_grading_code: |-
              """Provide feedback to student based on evaluation of JavaScript programming quiz."""

              import json

              # until we check, assume student's submission is incorrect
              grade_result['correct'] = False

              # don't use, but must set to ' ' to avoid error
              grade_result['comment'] = ' '

              # use default markdown?
              use_default_markdown = True

              def parse_swizzled_output(output):
                  """Analyzes the swizzled output for passing/failing criteria and other feedback.
                      
                      Args:
                      output (string): Output generated when running swizzled main.
                      """
                  # keep running total of (passed) criteria
                  numberOfCriteria = 0
                  numberOfPasses = 0
                  passed_criteria = []
                  failed_criteria = []
                  feedback = []
                  # split lines by newline
                  lines = output.split('\n')
                  # go line-by-line and find formatted tags for criteria
                  for line in lines:
                      if line.startswith('<PASS::>'):
                          numberOfCriteria += 1
                          numberOfPasses += 1
                          # strip tag and add criteria to array
                          passed_criteria.append(line[8:])
                      if line.startswith('<FAIL::>'):
                          numberOfCriteria += 1
                          # strip tag and add criteria to array
                          failed_criteria.append(line[8:])
                      if line.startswith('<FEEDBACK::>'):
                          # strip tag and add feedback to array
                          feedback.append(line[12:])
                  # return results
                  return (numberOfCriteria == numberOfPasses, passed_criteria, failed_criteria, feedback)

              def default_markdown_from_criteria(passing_criteria, failing_criteria):
                  """Generates default markdown-like string based on passing/failing criteria.

                      Args:
                      passing_criteria (list): All passing criteria from quiz
                      failing_criteria (list): All failing criteria from quiz
                      """
                  # init markdown-like string
                  markdown = ''
                  # was there more than 1 criteria?
                  if passing_criteria + failing_criteria > 1:
                      # add passing criteria to markdown
                      if len(passing_criteria) >= 1:
                          markdown += '# What Went Well\n\n'
                          for criteria in passing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                      # add failing criteria to markdown
                      if len(failing_criteria) >= 1:
                          markdown += '# What Went Wrong\n\n'
                          for criteria in failing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                  else:
                      # if only 1 criteria, add it without headers to markdown
                      markdown = passing_criteria[0] if grade_result['correct'] else failing_criteria[0]
                  # return markdown-like string
                  return markdown

              def main():
                  """Analyze the output generated by Falcon and set special key/value pairs for feedback."""
                  # did the remote execution cause an error?
                  if executor_result['stderr'] == '':
                      # nope! analyze the output (JSON-like string)
                      try:
                          # convert JSON-like string into Python dictionary
                          results = json.loads(executor_result['stdout'])
                          swizzle_out = results['temp/results-out.txt']
                      except Exception as e:
                          # if there was an error during the conversion, display it
                          grade_result['feedback'] = executor_result['stderr']
                      else:
                          # did the execution of swizzled main produce an error?
                          if results['temp/results-err.txt'] == '':
                              # nope! we can safely use the output of swizzled main
                              (submission_correct, passing_criteria, failing_criteria, feedback) = parse_swizzled_output(swizzle_out)
                              # set pass/fail
                              grade_result['correct'] = submission_correct
                              if use_default_markdown == True:
                                  # use default markdown for criteria/feedback
                                  markdown_feedback = default_markdown_from_criteria(passing_criteria, failing_criteria)
                                  total_criteria = len(failing_criteria) + len(passing_criteria)
                                  all_feedback = markdown_feedback + '# Feedback\n\n'
                                  if len(failing_criteria) == 0:
                                      all_feedback += 'Your answer passed all our tests! Awesome job!'
                                  elif len(passing_criteria) >= total_criteria / 2:
                                      all_feedback += 'Not everything is correct yet, but you\'re close!'
                                  else:
                                      all_feedback += 'There\'s work left to do. Try tackling one problem at a time.'
                                  grade_result['feedback'] = all_feedback
                                  # grade_result['comment'] = results['temp/student-out.txt']
                              else:
                                  # show raw response from REX execution
                                  grade_result['feedback'] = str(results)
                          else:
                              # swizzled main generated some an error, so display it!
                              grade_result['feedback'] = 'An error occurred while testing your code.\n\nCheck to ensure these items are true:\n\n- clicking **TEST RUN** doesn\'t produce any issues\n- you\'ve followed all instructions\n- you\'ve used the correct names\n\nIf you make all these checks, but it still doesn\'t fix the error, then please contact us at *support@udacity.com* and provide a link to the quiz and a copy of your code.\n\nNOTE: If you cannot find the instructions, click **RESET QUIZ** to reset the quiz to its original state.'
                  else:
                      # there was an error with overall execution, so display it!
                      grade_result['comment'] = executor_result['stderr']

              main()
            requires_gpu: false
            deadline_seconds: 0
            legacy_template_refs:
              - key: '5141761099956224'
                ref: ProgramTemplate
            included_text_files:
              - text: |
                  /* eslint no-unused-vars: "off" */

                  function getASTMatches(esquery, tree, selector) {
                      var result = esquery.parse(selector);
                      return esquery.match(tree, result);
                  }

                  function bodyElementIsNotEmpty(body) {
                      return body[0].body.length !== 0;
                  }
                name: SwizzleBefore.js
              - text: |
                  /* global getASTMatches, bodyElementIsNotEmpty, uniqueFlavors, flavor1, flavor2 */

                  ;(function () { // eslint-disable-line no-extra-semi
                      const assert = require('chai').assert;
                      const esprima = require('esprima');
                      const esquery = require('esquery');
                      const content = require('fs').readFileSync(__dirname + '/StudentMain.js', 'utf8');

                      const AST = esprima.parse(content);
                      const body = getASTMatches(esquery, AST, '[body]');

                      if (bodyElementIsNotEmpty(body)) {
                          describe('Your code', function () {
                              it('should have a variable `uniqueFlavors`', function () {
                                  assert.isDefined(uniqueFlavors, 'You need to define the `uniqueFlavors` variable.');
                              });

                              it('should have a variable `flavor1`', function () {
                                  assert.isDefined(flavor1, 'You need to define the `flavor1` variable.');
                              });

                              it('should have a variable `flavor2`', function () {
                                  assert.isDefined(flavor2, 'You need to define the `flavor2` variable.');
                              });

                              it('should use the `.add()` method three times to add required items to the set', function () {
                                  const callsToAddMethod = getASTMatches(esquery, AST, 'CallExpression [name="add"]');

                                  assert.equal(callsToAddMethod.length, 3, 'You did not use `.add()` the required 3 times.');
                              });
                          });

                          describe('The `uniqueFlavors` object', function () {
                              it('should contain a "chocolate" flavor object', function () {
                                  assert.isTrue(uniqueFlavors.has(flavor1), '`uniqueFlavors` does not contain a "chocolate" flavor object');
                              });

                              it('should contain a custom flavor object', function () {
                                  assert.isTrue(uniqueFlavors.has(flavor2), '`uniqueFlavors` does not contain your custom object');
                              });
                          });
                      } else {
                          describe('Your code', function () {
                              it('should not be empty', function () {
                                  assert.isOk(false, 'Your code is missing, hit the "Reset Quiz" button to reset the quiz');
                              });
                          });
                      }

                  }());
                name: SwizzleAfter.js
        answer: null
  - id: 374321
    key: f8afc5fb-d3e1-416f-87dc-9745d6fc09d1
    locale: zh-cn
    version: 1.0.0
    title: Map
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:57 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374219
    atoms:
      - id: 374219
        key: b3f6b78c-4fd3-4544-8873-816ab11d1809
        locale: zh-cn
        version: 1.0.0
        title: 从 Set 到 Map
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:43:56 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43224'
          youtube_id: H5DJPfcN2P4
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/24-transition-from-sets-to-maps-1_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/24-transition-from-sets-to-maps-1_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/24-transition-from-sets-to-maps-1_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/24-transition-from-sets-to-maps-1_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422b43_24-transition-from-sets-to-maps-1/hls/playlist.m3u8'
  - id: 374323
    key: a9340848-55d9-490a-8ebd-72da5b111578
    locale: zh-cn
    version: 1.0.0
    title: 创建和修改 Map
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:58 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374220
      - 374221
      - 374222
    atoms:
      - id: 374220
        key: f4a417af-c319-4597-b9d9-c398b2ab98cf
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:57 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # Map（映射）

          如果说 Set 类似于数组，那么 Map 就类似于对象，因为 Map 存储键值对，和对象包含命名属性及值相类似。 

          本质上，Map 是一个可以存储键值对的对象，键和值都可以是对象、原始值或二者的结合。

          ## 如何创建 Map

          要创建 Map，只需输入：

          ```js
          const employees = new Map();
          console.log(employees);
          ```
          > `Map {}`

          这样就会创建空的 Map `employee`，没有键值对。
        instructor_notes: ''
        resources: null
      - id: 374221
        key: 666b348b-f195-4235-b7d5-ab838fc1e67c
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:58 GMT+0000 (UTC)'
        is_public: true
        text: |
          ## 修改 Map

          和 Set 不同，你无法使用值列表创建 Map；而是使用 Map 的 `.set()` 方法添加键值。 

          ```js
          const employees = new Map();

          employees.set('james.parkes@udacity.com', { 
              firstName: 'James',
              lastName: 'Parkes',
              role: 'Content Developer' 
          });
          employees.set('julia@udacity.com', {
              firstName: 'Julia',
              lastName: 'Van Cleve',
              role: 'Content Developer'
          });
          employees.set('richard@udacity.com', {
              firstName: 'Richard',
              lastName: 'Kalehoff',
              role: 'Content Developer'
          });

          console.log(employees);
          ```
          > `Map {'james.parkes@udacity.com' => Object {...}, 'julia@udacity.com' => Object {...}, 'richard@udacity.com' => Object {...}}`

          `.set()` 方法有两个参数。第一个参数是键，用来引用第二个参数，即值。

          要移除键值对，只需使用 `.delete()` 方法。

          ```js
          employees.delete('julia@udacity.com');
          employees.delete('richard@udacity.com');
          console.log(employees);
          ```
          > `Map {'james.parkes@udacity.com' => Object {firstName: 'James', lastName: 'Parkes', role: 'Course Developer'}}`

          同样，和 Set 类似，你可以使用 `.clear()` 方法从 Map 中删除所有键值对。

          ```js
          employees.clear()
          console.log(employees);
          ```
          > `Map {}`
        instructor_notes: ''
        resources: null
      - id: 374222
        key: 6d1c85b1-0012-4642-8d4b-49a982dc6bff
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:58 GMT+0000 (UTC)'
        is_public: true
        text: |-
          > **提示**：如果你使用 `.set()` 向 Map 中添加键已存在的键值对，不会收到错误，但是该键值对将覆盖 Map 中的现有键值对。此外，如果尝试使用 `.delete()` 删除 Map 中不存在的键值，不会收到错误，而 Map 会保持不变。

          > 如果成功地删除了键值对，`.delete()` 方法会返回 `true`，失败则返回 `false`。`.set()` 如果成功执行，则返回 `Map` 对象本身。
        instructor_notes: ''
        resources: null
  - id: 374324
    key: e5bcc668-11da-4ec0-84ef-d9f51e19f2b4
    locale: zh-cn
    version: 1.0.0
    title: 使用 Map
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:43:59 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374223
    atoms:
      - id: 374223
        key: 8fff6f20-e040-463a-9d0b-c0814072f94e
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:59 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 使用 Map

          构建 Map 后，可以使用 `.has()` 方法，并向其传入一个键来检查 Map 中是否存在该键值对。

          ```js
          const members = new Map();

          members.set('Evelyn', 75.68);
          members.set('Liam', 20.16);
          members.set('Sophia', 0);
          members.set('Marcus', 10.25);

          console.log(members.has('Xavier'));
          console.log(members.has('Marcus'));
          ```
          > `false`<br>
          > `true`

          还可以通过向 `.get()` 方法传入一个键，检索 Map 中的值。

          ```js
          console.log(members.get('Evelyn'));
          ```
          > `75.68`
        instructor_notes: ''
        resources: null
  - id: 374325
    key: e221c233-0e17-4b16-8aba-c42212c33250
    locale: zh-cn
    version: 1.0.0
    title: 循环访问 Map
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:03 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374224
      - 374225
      - 374226
      - 374227
    atoms:
      - id: 374224
        key: e976b1b6-4715-4f6e-a880-c1b450544a8b
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:43:59 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # 循环访问 Map
          你已经创建了 Map，添加了一些键值对，现在你想循环访问该 Map。幸运的是，可以通过以下三种方式循环访问：

          1. 使用 Map 的默认迭代器循环访问每个键或值
          2. 使用新的 `for...of` 循环来循环访问每个键值对
          3. 使用 Map 的 `.forEach()` 方法循环访问每个键值对

          ## 1. 使用 MapIterator

          在 Map 上使用 `.keys()` 和 `.values()` 方法将返回新的迭代器对象，叫做 `MapIterator`。你可以将该迭代器对象存储在新的变量中，并使用 `.next()` 循环访问每个键或值。你所使用的方法将决定迭代器是否能够访问 Map 的键或值。

          ```js
          let iteratorObjForKeys = members.keys();
          iteratorObjForKeys.next();
          ```
          > `Object {value: 'Evelyn', done: false}`

          使用 `.next()` 获得下个键值对。

          ```js
          iteratorObjForKeys.next();
          ```
          > `Object {value: 'Liam', done: false}`

          等等。

          ```js
          iteratorObjForKeys.next();
          ```
          > `Object {value: 'Sophia', done: false}`

          另一方面，使用 `.values()` 方法访问 Map 的值，然后重复同一流程。

          ```js
          let iteratorObjForValues = members.values();
          iteratorObjForValues.next();
          ```
          > `Object {value: 75.68, done: false}`
        instructor_notes: ''
        resources: null
      - id: 374225
        key: dca659d0-f686-4f6c-ad9c-8749d880a8d5
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:00 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 2. 使用 for...of 循环

          Map 的第二种循环访问方式是使用 `for...of` 循环。

          ```js
          for (const member of members) {
            console.log(member);
          }
          ```
          > ```
           ['Evelyn', 75.68]
           ['Liam', 20.16]
           ['Sophia', 0]
           ['Marcus', 10.25]
          ```

          但是，在对 Map 使用 `for...of` 循环时，并不会得到一个键值或一个值。键值对会拆分为一个数组，第一个元素是键，第二个元素是值。有没有什么方法可以解决这一问题？
        instructor_notes: ''
        resources: null
      - id: 374226
        key: ac6347f1-4a78-4f1a-8f4c-00e657c67521
        locale: zh-cn
        version: 1.0.0
        title: ''
        semantic_type: QuizAtom
        updated_at: 'Mon Sep 11 2017 16:44:02 GMT+0000 (UTC)'
        is_public: true
        resources: null
        instructor_notes: ''
        instruction: null
        question:
          title: ''
          semantic_type: ProgrammingQuestion
          evaluation_id: '6350730081468416'
          evaluator:
            model: ProgramEvaluator
            execution_language: python
            executor_grading_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'submit'])
            executor_test_code: |-
              import falcon.util as util

              util.run_program(['python', 'falcon.py', '-s', 'js_mocha', '-m', 'test'])
            gae_grading_code: |-
              """Provide feedback to student based on evaluation of JavaScript programming quiz."""

              import json

              # until we check, assume student's submission is incorrect
              grade_result['correct'] = False

              # don't use, but must set to ' ' to avoid error
              grade_result['comment'] = ' '

              # use default markdown?
              use_default_markdown = True

              def parse_swizzled_output(output):
                  """Analyzes the swizzled output for passing/failing criteria and other feedback.
                      
                      Args:
                      output (string): Output generated when running swizzled main.
                      """
                  # keep running total of (passed) criteria
                  numberOfCriteria = 0
                  numberOfPasses = 0
                  passed_criteria = []
                  failed_criteria = []
                  feedback = []
                  # split lines by newline
                  lines = output.split('\n')
                  # go line-by-line and find formatted tags for criteria
                  for line in lines:
                      if line.startswith('<PASS::>'):
                          numberOfCriteria += 1
                          numberOfPasses += 1
                          # strip tag and add criteria to array
                          passed_criteria.append(line[8:])
                      if line.startswith('<FAIL::>'):
                          numberOfCriteria += 1
                          # strip tag and add criteria to array
                          failed_criteria.append(line[8:])
                      if line.startswith('<FEEDBACK::>'):
                          # strip tag and add feedback to array
                          feedback.append(line[12:])
                  # return results
                  return (numberOfCriteria == numberOfPasses, passed_criteria, failed_criteria, feedback)

              def default_markdown_from_criteria(passing_criteria, failing_criteria):
                  """Generates default markdown-like string based on passing/failing criteria.

                      Args:
                      passing_criteria (list): All passing criteria from quiz
                      failing_criteria (list): All failing criteria from quiz
                      """
                  # init markdown-like string
                  markdown = ''
                  # was there more than 1 criteria?
                  if passing_criteria + failing_criteria > 1:
                      # add passing criteria to markdown
                      if len(passing_criteria) >= 1:
                          markdown += '# What Went Well\n\n'
                          for criteria in passing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                      # add failing criteria to markdown
                      if len(failing_criteria) >= 1:
                          markdown += '# What Went Wrong\n\n'
                          for criteria in failing_criteria:
                              markdown += '<li style="list-style-type: none;">- ' + criteria + '</li>'
                          markdown += '\n'
                  else:
                      # if only 1 criteria, add it without headers to markdown
                      markdown = passing_criteria[0] if grade_result['correct'] else failing_criteria[0]
                  # return markdown-like string
                  return markdown

              def main():
                  """Analyze the output generated by Falcon and set special key/value pairs for feedback."""
                  # did the remote execution cause an error?
                  if executor_result['stderr'] == '':
                      # nope! analyze the output (JSON-like string)
                      try:
                          # convert JSON-like string into Python dictionary
                          results = json.loads(executor_result['stdout'])
                          swizzle_out = results['temp/results-out.txt']
                      except Exception as e:
                          # if there was an error during the conversion, display it
                          grade_result['feedback'] = executor_result['stderr']
                      else:
                          # did the execution of swizzled main produce an error?
                          if results['temp/results-err.txt'] == '':
                              # nope! we can safely use the output of swizzled main
                              (submission_correct, passing_criteria, failing_criteria, feedback) = parse_swizzled_output(swizzle_out)
                              # set pass/fail
                              grade_result['correct'] = submission_correct
                              if use_default_markdown == True:
                                  # use default markdown for criteria/feedback
                                  markdown_feedback = default_markdown_from_criteria(passing_criteria, failing_criteria)
                                  total_criteria = len(failing_criteria) + len(passing_criteria)
                                  all_feedback = markdown_feedback + '# Feedback\n\n'
                                  if len(failing_criteria) == 0:
                                      all_feedback += 'Your answer passed all our tests! Awesome job!'
                                  elif len(passing_criteria) >= total_criteria / 2:
                                      all_feedback += 'Not everything is correct yet, but you\'re close!'
                                  else:
                                      all_feedback += 'There\'s work left to do. Try tackling one problem at a time.'
                                  grade_result['feedback'] = all_feedback
                                  # grade_result['comment'] = results['temp/student-out.txt']
                              else:
                                  # show raw response from REX execution
                                  grade_result['feedback'] = str(results)
                          else:
                              # swizzled main generated some an error, so display it!
                              grade_result['feedback'] = 'An error occurred while testing your code.\n\nCheck to ensure these items are true:\n\n- clicking **TEST RUN** doesn\'t produce any issues\n- you\'ve followed all instructions\n- you\'ve used the correct names\n\nIf you make all these checks, but it still doesn\'t fix the error, then please contact us at *support@udacity.com* and provide a link to the quiz and a copy of your code.\n\nNOTE: If you cannot find the instructions, click **RESET QUIZ** to reset the quiz to its original state.'
                  else:
                      # there was an error with overall execution, so display it!
                      grade_result['comment'] = executor_result['stderr']

              main()
            requires_gpu: false
            deadline_seconds: 0
            legacy_template_refs:
              - key: '5141761099956224'
                ref: ProgramTemplate
            included_text_files:
              - text: |
                  /* eslint no-unused-vars: "off" */

                  function getASTMatches(esquery, tree, selector) {
                      var result = esquery.parse(selector);
                      return esquery.match(tree, result);
                  }

                  function bodyElementIsNotEmpty(body) {
                      return body[0].body.length !== 0;
                  }
                name: SwizzleBefore.js
              - text: |
                  /* global getASTMatches, bodyElementIsNotEmpty, members */

                  ;(function () { // eslint-disable-line no-extra-semi
                      const assert = require('chai').assert;
                      const esprima = require('esprima');
                      const esquery = require('esquery');
                      const content = require('fs').readFileSync(__dirname + '/StudentMain.js', 'utf8');

                      const AST = esprima.parse(content);
                      const body = getASTMatches(esquery, AST, '[body]');

                      if (bodyElementIsNotEmpty(body)) {
                          describe('Your code', function () {
                              it('should have a `members` variable', function () {
                                  assert.isDefined(members, '`members` does not exist');
                              });

                              it('should use destructuring', function () {
                                  var destructoringMatch = getASTMatches(esquery, AST, 'ForOfStatement ArrayPattern');

                                  assert.equal(destructoringMatch.length, 1, 'Your code does not use array destructuring');
                              });
                          });

                          describe('`members`', function () {
                              it('should be a Map', function () {
                                  assert.isTrue(members instanceof Map, '`members` should be a Map object');
                              });
                          });
                      } else {
                          describe('Your code', function () {
                              it('should not be empty', function () {
                                  assert.isOk(false, 'Your code is missing, hit the "Reset Quiz" button to reset the quiz');
                              });
                          });
                      }

                  }());
                name: SwizzleAfter.js
        answer: null
      - id: 374227
        key: b18db3a8-86ce-4408-9aaf-39ce44fa864a
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:03 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 3. 使用 forEach 循环

          最后一种循环访问 Map 的方式是使用 `.forEach()` 方法。

          ```js
          members.forEach((value, key) => console.log(value, key));
          ```
          > ```
           'Evelyn' 75.68
           'Liam' 20.16
           'Sophia' 0
           'Marcus' 10.25
          ```

          注意，在使用箭头函数后，`forEach` 循环是如何简单地读取数据的。对于 `members` 中的每个 value 和 key，都会被输出到控制台中。
        instructor_notes: ''
        resources: null
  - id: 374327
    key: ae0439c3-436c-4c2f-ba69-8bfc7f947a6c
    locale: zh-cn
    version: 1.0.0
    title: WeakMap（弱映射）
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:05 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374228
      - 374229
      - 374230
      - 374231
      - 374232
    atoms:
      - id: 374228
        key: f61c5595-2770-49a1-b9dc-3bdbf90b883d
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:04 GMT+0000 (UTC)'
        is_public: true
        text: '> **提示**：如果你已经看过 WeakSet 部分，那么这部分相当于复习了。WeakMap 的行为和 WeakSet 的一样，只是 WeakMap 处理的是键值对，而不是单个条目。'
        instructor_notes: ''
        resources: null
      - id: 374229
        key: 1b60cad4-fcb7-4fdc-a883-9230477ab2c4
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:04 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # 什么是 WeakMap？

          WeakMap 和普通 Map 很像，但是具有以下关键区别：

          1. WeakMap 只能包含对象作为键值，
          2. WeakMap 无法迭代，意味着无法循环访问，并且
          3. WeakMap 没有 `.clear()` 方法。

          你可以像创建普通 Map 那样创建 WeakMap，但是需要使用 `WeakMap` 构造函数。

          ```js
          const book1 = { title: 'Pride and Prejudice', author: 'Jane Austen' };
          const book2 = { title: 'The Catcher in the Rye', author: 'J.D. Salinger' };
          const book3 = { title: 'Gulliver's Travels', author: 'Jonathan Swift' };

          const library = new WeakMap();
          library.set(book1, true);
          library.set(book2, false);
          library.set(book3, true);

          console.log(library);
          ```
          > `WeakMap {Object {title: 'Pride and Prejudice', author: 'Jane Austen'} => true, Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false, Object {title: 'Gulliver's Travels', author: 'Jonathan Swift'} => true}`

          但是如果你尝试添加对象以外的内容作为键值，系统将报错！

          ```js
          library.set('The Grapes of Wrath', false);
          ```
          > `Uncaught TypeError: Invalid value used as weak map key(…)`

          这是可预期到的行为，因为 WeakMap 只能包含对象作为键值。同样，和 WeakSet 相似，WeakMap 利用垃圾回收机制让其可以更简单地使用和易维护。
        instructor_notes: ''
        resources: null
      - id: 374230
        key: 67d295c9-31b2-409b-aaab-4f9ab8c6fba1
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:04 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 垃圾回收

          在 JavaScript 中，创建新的值时会分配内存，并且当这些值不再需要时，将自动释放内存。这种内存不再需要后释放内存的过程称为**垃圾回收**。

          WeakMap 通过专门使用对象作为键值来利用这一点。如果将对象设为 `null`，则本质上是删除该对象。当 JavaScript 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。

          ```js
          book1 = null;
          console.log(library);
          ```
          > `WeakMap {Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false, Object {title: 'Gulliver’s Travels', author: 'Jonathan Swift'} => true}`
        instructor_notes: ''
        resources: null
      - id: 374231
        key: 147acdd2-2fb0-4ffc-8b06-7ad35c5609c2
        locale: zh-cn
        version: 1.0.0
        title: WeakMap 动画
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:44:04 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '54437'
          youtube_id: sUE_JjiF_q4
          subtitles: []
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011d62_ud356-l3-weakmaps-animation/ud356-l3-weakmaps-animation_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011d62_ud356-l3-weakmaps-animation/ud356-l3-weakmaps-animation_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011d62_ud356-l3-weakmaps-animation/ud356-l3-weakmaps-animation_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011d62_ud356-l3-weakmaps-animation/ud356-l3-weakmaps-animation_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2017/April/59011d62_ud356-l3-weakmaps-animation/hls/playlist.m3u8'
      - id: 374232
        key: 6774b4fd-8305-40ef-b5cc-63cf9e60ab4b
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Wed Sep 20 2017 06:49:30 GMT+0000 (UTC)'
        is_public: true
        text: |-
          这种机制的好处在于你不用去担心要删掉对 WeakMap 中已删除对象的引用，JavaScript 会帮你删除！如果对象被删除，当垃圾回收器运行时，该对象也会从弱映射中删除。这样的话，如果你想要一种高效、轻便的解决方法去创建一组具有元数据的对象，就可以使用 WeakMap。

          垃圾回收的发生时间点取决于很多因素。请参阅 [MDN 的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#垃圾回收)，详细了解用于处理 JavaScript 中的垃圾回收的算法。
        instructor_notes: ''
        resources: null
  - id: 374326
    key: c445893d-48a1-422c-9201-f69b4cda71d8
    locale: zh-cn
    version: 1.0.0
    title: Promise 简介
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:06 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374233
    atoms:
      - id: 374233
        key: 98c39f5d-7e0c-43a1-90ed-e0dc4b3287fe
        locale: zh-cn
        version: 1.0.0
        title: Promise 简介
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:44:05 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43141'
          youtube_id: 8L1a-_c8mCg
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/583f7c74_40-promises-intro/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c74_40-promises-intro/40-promises-intro_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c74_40-promises-intro/40-promises-intro_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c74_40-promises-intro/40-promises-intro_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c74_40-promises-intro/40-promises-intro_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c74_40-promises-intro/hls/playlist.m3u8'
  - id: 374328
    key: efb32aa3-9b21-4f1e-acf1-162d0498472b
    locale: zh-cn
    version: 1.0.0
    title: Promise
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:07 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374234
      - 374235
      - 374236
      - 374237
    atoms:
      - id: 374234
        key: d5c3f1b5-2e0a-44f5-888d-03e4d0b14cc1
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Wed Sep 20 2017 07:16:25 GMT+0000 (UTC)'
        is_public: true
        text: |-
          # Promise
          JavaScript Promise 是用新的 [Promise 构造函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) - `new Promise()` 创建而成的。promise 使你能够展开一些可以**异步**完成的工作，并回到常规工作。创建 promise 时，必须向其提供异步运行的代码。将该代码当做参数提供给构造函数：

          ```js
          new Promise(function () {
              window.setTimeout(function createSundae(flavor = 'chocolate') {
                  const sundae = {};
                  // request ice cream
                  // get cone
                  // warm up ice cream scoop
                  // scoop generous portion into cone!
              }, Math.random() * 2000);
          });
          ```

          该代码在我发出请求时将会创建一个 promise，并且在几秒钟后启动。然后需要在 `createSundae` 函数中执行几个步骤。

          ## 指示一个成功请求或者失败请求

          但是完成这一切后，JavaScript 如何通知我们它已经完成操作，准备好让我们恢复工作？它通过向初始函数中传入两个函数来实现这一点，通常我们将这两个函数称为 `resolve` 和 `reject`。
        instructor_notes: ''
        resources: null
      - id: 374235
        key: 6ad64ae8-4bdc-40fe-91e9-513df3823a15
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:06 GMT+0000 (UTC)'
        is_public: true
        text: |-
          该函数被传递给我们向 Promise 构造函数提供的函数 - 通常单词"resolve"用于表示当请求成功完成时，应该调用此函数。请注意第一行的 `resolve`：

          ```js
          new Promise(function (resolve, reject) {
              window.setTimeout(function createSundae(flavor = 'chocolate') {
                  const sundae = {};
                  // request ice cream
                  // get cone
                  // warm up ice cream scoop
                  // scoop generous portion into cone!
                  resolve(sundae);
              }, Math.random() * 2000);
          });
          ```

          当 sundae 被成功创建后，它会调用 `resolve` 方法并向其传递我们要返回的数据，在本例中，返回的数据是完成的 sundae。因此 `resolve` 方法用来表示请求已完成，并且*成功*完成了请求。
        instructor_notes: ''
        resources: null
      - id: 374236
        key: 4cd01a23-da42-4937-9ab6-dd6a621fc2c3
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:07 GMT+0000 (UTC)'
        is_public: true
        text: |-
          如果请求存在问题，无法完成请求，那么我们可以使用传递给该函数的第二个函数。通常，该函数存储在一个叫做"reject"的标识符中，表示如果请求因为某种原因失败了，应该使用该函数。请看看第一行的 `reject`：

          ```js
          new Promise(function (resolve, reject) {
              window.setTimeout(function createSundae(flavor = 'chocolate') {
                  const sundae = {};
                  // request ice cream
                  // get cone
                  // warm up ice cream scoop
                  // scoop generous portion into cone!
                  if ( /* iceCreamConeIsEmpty(flavor) */ ) {
                      reject(`Sorry, we're out of that flavor :-(`);
                  }
                  resolve(sundae);
              }, Math.random() * 2000);
          });
          ```

          如果请求*无法完成*，则用到了 `reject` 方法。注意，即使请求失败了，我们依然可以返回数据，在本例中，我们只是返回了一段文字，表示没有我们想要的冰激凌口味。
        instructor_notes: ''
        resources: null
      - id: 374237
        key: 2f74361b-0a7d-4fc0-9b8d-4581d4db8d22
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:07 GMT+0000 (UTC)'
        is_public: true
        text: |-
          Promise 构造函数需要一个可以运行的函数，运行一段时间后，将成功完成（使用 `resolve` 方法）或失败（使用 `reject` 方法）。当结果最终确定时（请求成功完成或失败），现在 promise 已经 *实现* 了，并且将通知我们，这样我们便能决定将如何对结果做处理。

          ## Promise 立即返回对象
          首先要注意的是，Promise 将立即返回一个对象。

          ```js
          const myPromiseObj = new Promise(function (resolve, reject) {
              // sundae creation code
          });
          ```

          该对象上具有一个 `.then()` 方法，我们可以让该方法通知我们 promise 中的请求成功与否。`.then()` 方法会接收两个函数：

          1. 请求成功完成时要运行的函数
          * 请求失败时要运行的函数

          ```js
          mySundae.then(function(sundae) {
              console.log(`Time to eat my delicious ${sundae}`);
          }, function(msg) {
              console.log(msg);
              self.goCry(); // not a real method
          });
          ```

          可以看出，传递给 `.then()` 的第一个函数将被调用，并传入 Promise 的 `resolve` 函数需要使用的数据。这里，该函数将接收 `sundae` 对象。第二个函数传入的数据会在 Promise 的 `reject` 函数被调用时使用。这里，该函数收到错误消息"Sorry, we're out of that flavor :-("，在上述 Promise 代码中，`reject` 函数被调用。 
        instructor_notes: ''
        resources: null
  - id: 374329
    key: 70ec68a8-7d13-4ec7-8b98-303d7bbc78a8
    locale: zh-cn
    version: 1.0.0
    title: 更多 Promise
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:08 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374238
      - 374239
    atoms:
      - id: 374238
        key: a4c106d8-657c-4b1c-9862-c000f852d1de
        locale: zh-cn
        version: 1.0.0
        title: 更多 Promise
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:44:08 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43225'
          youtube_id: 8CxDIR2tH9A
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/58422c79_45-handoff/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422c79_45-handoff/45-handoff_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422c79_45-handoff/45-handoff_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422c79_45-handoff/45-handoff_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422c79_45-handoff/45-handoff_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/58422c79_45-handoff/hls/playlist.m3u8'
      - id: 374239
        key: 8fd703f1-21c0-477e-84d5-ffcbc6ef3ab6
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:08 GMT+0000 (UTC)'
        is_public: true
        text: |-
          请参阅我们的 [Promises 课程](https://www.udacity.com/course/javascript-promises--ud898)，详细了解以下内容：

          * JavaScript Promise
          * 如何处理返回的数据和错误
          * 构建一个叫做 Exoplanet Explorer 的应用，并使用 JavaScript Promise 异步获取远程数据
        instructor_notes: ''
        resources: null
  - id: 374330
    key: 8e7ad09f-5f31-4a62-b6ee-9fed8b177474
    locale: zh-cn
    version: 1.0.0
    title: Proxy 简介
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:09 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374240
    atoms:
      - id: 374240
        key: 8d305bd8-295f-4ea4-a036-8e7407c682ea
        locale: zh-cn
        version: 1.0.0
        title: Proxy 简介
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:44:09 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43143'
          youtube_id: lYXhxgt6suk
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/583f7c85_46-proxy-intro/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c85_46-proxy-intro/46-proxy-intro_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c85_46-proxy-intro/46-proxy-intro_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c85_46-proxy-intro/46-proxy-intro_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c85_46-proxy-intro/46-proxy-intro_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c85_46-proxy-intro/hls/playlist.m3u8'
  - id: 374331
    key: 2bae49bd-919f-4051-a066-cb89a9a21b6f
    locale: zh-cn
    version: 1.0.0
    title: Proxy
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:10 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374241
      - 374242
      - 374243
    atoms:
      - id: 374241
        key: b2b2acef-fa60-4d0f-8257-1985ee50eeeb
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:09 GMT+0000 (UTC)'
        is_public: true
        text: |
          要创建 Proxy（代理）对象，我们使用 Proxy 构造函数 `new Proxy();`。Proxy 构造函数接收两个项目：
          * 它将要代理的对象
          * 包含将为被代理对象处理的方法列表的对象

          第二个对象叫做**处理器**.

          ## Proxy内的一个传递
          创建 Proxy 的最简单方式是提供对象和空的 handler（处理器）对象。

          ```js
          var richard = {status: 'looking for work'};
          var agent = new Proxy(richard, {});

          agent.status; // returns 'looking for work'
          ```

          上述代码并没有对 Proxy 执行任何特殊操作，只是将请求直接传递给源对象！如果我们希望 Proxy 对象截获请求，这就是 handler 对象的作用了！
        instructor_notes: ''
        resources: null
      - id: 374242
        key: 0e443618-1eb3-4001-ab76-5cf0d1f2fa5d
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:09 GMT+0000 (UTC)'
        is_public: true
        text: |-
          让 Proxy 变得有用的关键是当做第二个对象传递给 Proxy 构造函数的 handler 对象。handler 对象由将用于访问属性的方法构成。我们看看 `get`：

          ## Get Trap（捕获器）
          `get` 用来截获对属性的调用：

          ```js
          const richard = {status: 'looking for work'};
          const handler = {
              get(target, propName) {
                  console.log(target); // the `richard` object, not `handler` and not `agent`
                  console.log(propName); // the name of the property the proxy (`agent` in this case) is checking
              }
          };
          const agent = new Proxy(richard, handler);
          agent.status; // logs out the richard object (not the agent object!) and the name of the property being accessed (`status`)
          ```

          在上述代码中，`handler` 对象具有一个 `get` 方法（因为被用在 Proxy 中，所以将"function"（方法）称之为"trap"（捕获器））。当代码 `agent.status;` 在最后一行运行时，因为存在 `get` 捕获器，它将截获该调用以获得 `status`（状态）属性并运行 `get` 捕获器方法。这样将会输出 Proxy 的目标对象（`richard` 对象），然后输出被请求的属性（`status` 属性）的名称。_它的作用就是这些！_它不会实际地输出属性！这很重要 —— *如果使用了捕获器，你需要确保为该捕获器提供所有的功能*。

          ### 从 Proxy 内部访问目标对象
          如果我们想真正地提供真实的结果，我们需要返回目标对象的属性：

          ```js
          const richard = {status: 'looking for work'};
          const handler = {
              get(target, propName) {
                  console.log(target);
                  console.log(propName);
                  return target[propName];
              }
          };
          const agent = new Proxy(richard, handler);
          agent.status; // (1)logs the richard object, (2)logs the property being accessed, (3)returns the text in richard.status
          ```

          注意我们在 `get` 捕获器的最后一行添加了 `return target[propName];`，这样将会访问目标对象的属性并返回它。 

          ### 直接获取 Proxy 的返回信息
          此外，我们可以使用 Proxy 提供直接的反馈：

          ```js
          const richard = {status: 'looking for work'};
          const handler = {
              get(target, propName) {
                  return `He's following many leads, so you should offer a contract as soon as possible!`;
              }
          };
          const agent = new Proxy(richard, handler);
          agent.status; // returns the text `He's following many leads, so you should offer a contract as soon as possible!`
          ```

          对于上述代码，Proxy 甚至不会检查目标对象，直接对调用代码做出响应。

          因此每当 Proxy 上的属性被访问，`get` 捕获器将接管任务。如果我们想截获调用以更改属性，则需要使用 `set` 捕获器！

          `set` 捕获器用来截获将更改属性的代码。`set` 捕获器将接收：
          它代理的对象
          被设置的属性
          Proxy 的新值

          ```js
          const richard = {status: 'looking for work'};
          const handler = {
              set(target, propName, value) {
                  if (propName === 'payRate') { // if the pay is being set, take 15% as commission
                      value = value * 0.85;
                  }
                  target[propName] = value;
              }
          };
          const agent = new Proxy(richard, handler);
          agent.payRate = 1000; // set the actor's pay to $1,000
          agent.payRate; // $850 the actor's actual pay
          ```

          在上述代码中，注意 `set` 捕获器会检查是否设置了 `payRate` 属性。如果设置了，Proxy 就从中拿走 15% 的费用作为自己的佣金！当演员的薪酬是一千美元时，因为 `payRate` 属性已设置，代码从中扣除 15% 的费用，并将实际 `payRate` 属性设为 `850`；
        instructor_notes: ''
        resources: null
      - id: 374243
        key: 654e96d2-936a-4841-aff4-3853eba6c093
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Wed Sep 20 2017 07:40:45 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 其他 trap
          我们查看了 `get` 和 `set`（可能是你最常用到的捕获器），但是实际上总共有 13 种不同的捕获器，它们都可以用在处理器中！

          1. [get trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get) - 使 proxy 能处理对属性访问权的调用
          2. [set trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set) - 使 proxy 能将属性设为新值
          3. [apply trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply) - 使 proxy 能被调用（被代理的对象是函数）
          4. [has trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has) - 使 proxy 能使用 `in` 运算符
          5. [deleteProperty trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty) - 使 proxy 能确定属性是否被删除
          6. [ownKeys trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys) - 使 proxy 能处理当所有键被请求时的情况
          7. [construct trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct) - 使 proxy 能处理 proxy 与 `new` 关键字一起使用当做构造函数的情形
          8. [defineProperty trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty) - 使 proxy 能处理当 defineProperty 被用于创建新的对象属性的情形
          9. [getOwnPropertyDescriptor trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor) - 使 proxy 能获得属性的描述符
          10. [preventExtenions trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions) - 使 proxy 能对 proxy 对象调用 `Object.preventExtensions()`
          11. [isExtensible trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible) - 使 proxy 能对 proxy 对象调用 `Object.isExtensible`
          12. [getPrototypeOf trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf) - 使 proxy 能对 proxy 对象调用 `Object.getPrototypeOf` 
          13. [setPrototypeOf trap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf) - 使 proxy 能对 proxy 对象调用 `Object.setPrototypeOf`

          可以看出，有很多 trap 可以让 proxy 管理如何处理被代理的对象的调用。
        instructor_notes: ''
        resources: null
  - id: 374333
    key: cea200b2-165e-463b-b223-92efcbe91288
    locale: zh-cn
    version: 1.0.0
    title: Proxy 与 ES5 Getter/Setter
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:10 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374244
    atoms:
      - id: 374244
        key: 078597d6-6197-4694-b7ec-19243eb07fbb
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:10 GMT+0000 (UTC)'
        is_public: true
        text: |

          一开始，可能不太清楚的是，ES5 中已经提供了 getter 和 setter 方法，为何还要 Proxy。对于 ES5 的 getter 和 setter 方法，你需要提前知道要获取/设置的属性：

          ```js
          var obj = {
              _age: 5,
              _height: 4,
              get age() {
                  console.log(`getting the "age" property`);
                  console.log(this._age);
              },
              get height() {
                  console.log(`getting the "height" property`);
                  console.log(this._height);
              }
          };
          ```

          对于上述代码，注意在初始化对象时，我们需要设置 `get age()` 和 `get height()`。因此，当我们调用下面的代码时，将获得以下结果：

          ```js
          obj.age; // logs 'getting the "age" property' & 5
          obj.height; // logs 'getting the "height" property' & 4
          ```

          但是当我们向该对象添加新的属性时，看看会发生什么：

          ```js
          obj.weight = 120; // set a new property on the object
          obj.weight; // logs just 120
          ```

          注意，并没有显示 `age` 和 `height` 属性那样生成的 `getting the "weight" property` 消息。

          对于 ES6 中的 Proxy，我们不需要提前知道这些属性*：

          ```js
          const proxyObj = new Proxy({age: 5, height: 4}, {
              get(targetObj, property) {
                  console.log(`getting the ${property} property`);
                  console.log(targetObj[property]);
              }
          });

          proxyObj.age; // logs 'getting the age property' & 5
          proxyObj.height; // logs 'getting the height property' & 4
          ```

          就像 ES5 代码那样一切正常，但是当我们添加新的属性时，看看会发生什么：

          ```js
          proxyObj.weight = 120; // set a new property on the object
          proxyObj.weight; // logs 'getting the weight property' & 120
          ```

          看到了吗？！？向 proxy 对象中添加了 `weight` 属性，稍后检索它时，它显示了一条日志消息！

          因此 proxy 对象的某些功能可能看起来类似于现有的 ES5 getter/setter 方法，但是对于 proxy，在初始化对象时，不需要针对每个属性使用 getter/setter 初始化对象。
        instructor_notes: ''
        resources: null
  - id: 374332
    key: 678533c6-6787-4261-a5e7-c2361a2bc1e2
    locale: zh-cn
    version: 1.0.0
    title: Proxy 小结
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:11 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374245
    atoms:
      - id: 374245
        key: 2926bd68-1111-464a-ba9d-637513c92622
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:11 GMT+0000 (UTC)'
        is_public: true
        text: |-
          Proxy 对象介于真正的对象和调用代码之间。调用代码与 Proxy 交互，而不是真正的对象。要创建 Proxy：

          * 使用 `new Proxy()` 构造函数
            * 将被代理的对象传入为第一项
            * 第二个对象是 handler（处理器）对象
          * handler 对象由 13 种不同的 trap（捕获器）之一构成
          * trap 是一种函数，将截获对属相的调用，让你运行代码
          * 如果未定义 trap，默认行为会被发送给目标对象

          Proxy 是一种强大的创建和管理对象之间的交互的新方式。
        instructor_notes: ''
        resources: null
  - id: 374334
    key: 87001b69-93ed-4934-b221-bf6008ea49e0
    locale: zh-cn
    version: 1.0.0
    title: 生成器
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:12 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374246
      - 374247
      - 374248
    atoms:
      - id: 374246
        key: 00f81cb0-ef2c-4bcf-a36e-0d9d53dceb08
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:11 GMT+0000 (UTC)'
        is_public: true
        text: |
          每当函数被调用时，JavaScript 引擎就会在函数顶部启动，并运行每行代码，直到到达底部。无法中途停止运行代码，并稍后重新开始。一直都是这种**“运行到结束”**的工作方式：

          ```js
          function getEmployee() {
              console.log('the function has started');

              const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

              for (const name of names) {
                  console.log(name);
              }

              console.log('the function has ended');
          }

          getEmployee();
          ```

          运行上述代码将在控制台中输出以下内容：

          ```text
          the function has started
          Amanda
          Diego
          Farrin
          James
          Kagure
          Kavita
          Orit
          Richard
          the function has ended
          ```

          如果你想先输出前三名员工的姓名，然后停止一段时间，稍后再从停下的地方继续输出更多员工的姓名呢？普通函数无法这么做，因为无法中途“暂停”运行函数。
        instructor_notes: ''
        resources: null
      - id: 374247
        key: 741dd448-79bb-4b33-8da3-f65db13a4a65
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:11 GMT+0000 (UTC)'
        is_public: true
        text: |
          ## 可暂停的函数


          如果我们希望能够中途暂停运行函数，则需要使用 ES6 中新提供的一种函数，叫做 generator（生成器）函数！我们来看一个示例：

          ```js
          function* getEmployee() {
              console.log('the function has started');

              const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

              for (const name of names) {
                  console.log( name );
              }

              console.log('the function has ended');
          }
          ```

          注意到 `function` 关键字后面的星号（即 `*`）了吗？星号表示该函数实际上是生成器！

          现在看看当我们尝试运行该函数时，会发生什么：

          ```js
          getEmployee();

          // this is the response I get in Chrome:
          getEmployee {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
          ```

          呃，什么？函数顶部的"the function has started"文本去哪了？为何控制台中没有输出任何姓名？问的好，但是先做个小练习。
        instructor_notes: ''
        resources: null
      - id: 374248
        key: 4705434e-afb0-4f88-964d-6c85a76fbf2f
        locale: zh-cn
        version: 1.0.0
        title: 生成器练习
        semantic_type: CheckboxQuizAtom
        updated_at: 'Mon Sep 11 2017 16:44:12 GMT+0000 (UTC)'
        is_public: true
        question:
          prompt: |-
            以下哪些是有效的生成器？请注意星号的位置。

            如果不确定，请尝试在浏览器的控制台中运行它们。
          correct_feedback: |-
            生成器的星号实际上可以放在 `function` 关键字和函数名称之间的任何位置。因此三个都是有效的生成器声明！

            ES6 社区基本同意将星号放在 `function` 关键字之后（即 `function* 名称() { … }`）。但是，其他人建议将星号放在函数名称前面。因此请务必注意，星号表示函数是生成器，但是星号的位置并不重要。
          video_feedback: null
          default_feedback: 再试一遍！生成器的星号实际上可以放在 `function` 关键字和函数名称之间的任何位置。
          answers:
            - id: a1484681360925
              text: '`function* names() { /* ... */ }`'
              is_correct: true
              incorrect_feedback: null
            - id: a1484681489259
              text: '`function * names() { /* ... */ }`'
              is_correct: true
              incorrect_feedback: null
            - id: a1484681497507
              text: '`function *names() { /* ... */ }`'
              is_correct: true
              incorrect_feedback: null
  - id: 374335
    key: 4ff98c20-fd97-4d86-ab2d-9d9ee659658c
    locale: zh-cn
    version: 1.0.0
    title: 生成器和迭代器
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:14 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374249
      - 374252
      - 374250
      - 374251
      - 374253
      - 374254
    atoms:
      - id: 374249
        key: 9f5b133b-83e9-4c1a-a6c8-9472703045df
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:12 GMT+0000 (UTC)'
        is_public: true
        text: '# 生成器和迭代器'
        instructor_notes: ''
        resources: null
      - id: 374252
        key: 134be4e2-e390-4931-b153-6c6b6e97e156
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:12 GMT+0000 (UTC)'
        is_public: true
        text: '> **警告：**我们在上一部分学习了迭代知识，如果你有点忘记了，请再复习一遍，因为在生成器这部分又会提到迭代！'
        instructor_notes: ''
        resources: null
      - id: 374250
        key: f276503a-a07e-4233-8b54-645494003a3c
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:13 GMT+0000 (UTC)'
        is_public: true
        text: |-
          生成器被调用时，它不会运行函数中的任何代码，而是创建和返回迭代器。该迭代器可以用来运行实际生成器的内部代码。

          ```js
          const generatorIterator = getEmployee();
          generatorIterator.next();
          ```
          **产生我们期望的代码：**

          ```text
          the function has started
          Amanda
          Diego
          Farrin
          James
          Kagure
          Kavita
          Orit
          Richard
          the function has ended
          ```

          如果你自己尝试运行这段代码，迭代器的 `.next()` 方法第一次被调用时，它会运行生成器中的所有代码。注意到什么了吗？代码始终没有暂停！那么我们要怎么才能实现神奇的暂停功能呢？
        instructor_notes: ''
        resources: null
      - id: 374251
        key: b89513a3-1513-4129-bcf2-b12edd75676e
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:13 GMT+0000 (UTC)'
        is_public: true
        text: |-
          ## 关键字 yield 

          关键字 `yield` 是 ES6 中新出现的关键字。只能用在生成器函数中。`yield` 会导致生成器暂停下来。我们向我们的生成器中添加 `yield`，试试看：

          ```js
          function* getEmployee() {
              console.log('the function has started');

              const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

              for (const name of names) {
                  console.log(name);
                  yield;
              }

              console.log('the function has ended');
          }
          ```

          注意，现在 `for...of` 循环中出现了 `yield`。如果我们调用该生成器（生成迭代器），然后调用 `.next()`，将获得以下输出：

          ```js
          const generatorIterator = getEmployee();
          generatorIterator.next();
          ```

          **将以下内容输出到控制台：**
          ```text
          the function has started
          Amanda
          ```

          暂停了！但是要真的确定下，我们看看下次迭代：

          ```js
          generatorIterator.next();
          ```

          **将输出以下内容到控制台：**
          ```text
          Diego
          ```

          它能完全记住上次停下的地方！它获取到数组中的下一项（Diego），记录它，然后再次触发了 `yield`，再次暂停。

          现在能够很好的暂停了，但是如果将数据从生成器返回到外面的世界呢？我们可以使用 `yield` 实现这一点。
        instructor_notes: ''
        resources: null
      - id: 374253
        key: d4e271f0-07a6-47db-b5f8-3e583b939ccc
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:13 GMT+0000 (UTC)'
        is_public: true
        text: |
          ## 向外面的世界生成数据


          我们不再向控制台输出姓名并暂停，而是让代码返回姓名并暂停。


          ```js
          function* getEmployee() {
              console.log('the function has started');

              const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

              for (const name of names) {
                  yield name;
              }

              console.log('the function has ended');
          }
          ```

          注意，现在从 `console.log(name);` 切换成了 `yield name;`。做出这一更改后，当生成器运行时，它会把姓名从函数里返回出去，然后暂停执行代码。我们看看具体效果：

          ```js
          const generatorIterator = getEmployee();
          let result = generatorIterator.next();
          result.value // is "Amanda"

          generatorIterator.next().value // is "Diego"
          generatorIterator.next().value // is "Farrin"
          ```
        instructor_notes: ''
        resources: null
      - id: 374254
        key: ad064c5c-a57d-4ae0-a90d-1e979784f70b
        locale: zh-cn
        version: 1.0.0
        title: Yield 练习
        semantic_type: RadioQuizAtom
        updated_at: 'Mon Sep 11 2017 16:44:14 GMT+0000 (UTC)'
        is_public: true
        question:
          prompt: |-
            迭代器的 `.next()` 方法需要被调用多少次，才能完全运行完/用尽下面的 `udacity` 生成器函数：

            ```js
            function* udacity() {
                yield 'Richard';
                yield 'James'
            }
            ```
          correct_feedback: |-
            它被调用的次数将比生成器函数中的 `yield` 表达式的数量多一次。

            对 `.next()` 的第一次调用将启动该函数，并运行为第一个 `yield`。对 `.next()` 的第二次调用将从暂停的地方继续，并运行第二个 `yield`。对 `.next()` 的第三次（即最后一次）调用将再次从暂停的地方继续，并运行到函数结尾处。
          video_feedback: null
          default_feedback: 它被调用的次数将比生成器函数中的 `yield` 表达式的数量多一次。
          answers:
            - id: a1484682161376
              text: 0 次
              is_correct: false
              incorrect_feedback: null
            - id: a1484682236438
              text: 1 次
              is_correct: false
              incorrect_feedback: null
            - id: a1484682239702
              text: 2 次
              is_correct: false
              incorrect_feedback: null
            - id: a1484682243203
              text: 3 次
              is_correct: true
              incorrect_feedback: null
  - id: 374338
    key: 2e54a053-1e9e-4b3f-b236-98270e6d628d
    locale: zh-cn
    version: 1.0.0
    title: 向生成器中发送数据或从中向外发送数据
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:16 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374255
      - 374256
      - 374257
    atoms:
      - id: 374255
        key: bdc453b3-4c9f-4764-80c7-51479b6b6078
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:14 GMT+0000 (UTC)'
        is_public: true
        text: |+

          我们可以使用关键字 yield 从生成器中获取数据。我们还可以将数据发送回生成器中。方式是使用 `.next()` 方法：

          ```js
          function* displayResponse() {
              const response = yield;
              console.log(`Your response is "${response}"!`);
          }

          const iterator = displayResponse();

          iterator.next(); // starts running the generator function
          iterator.next('Hello Udacity Student'); // send data into the generator
          // the line above logs to the console: Your response is "Hello Udacity Student"!
          ```

          使用数据调用 `.next()`（即 `.next('Richard')`）会将该数据发送到生成器函数中上次离开的地方。它会将 yield 关键字替换为你提供的数据。

          关键字 `yield` 用来暂停生成器并向生成器外发送数据，然后 `.next()` 方法用来向生成器中传入数据。下面是使用这两种过程来一次次地循环访问姓名列表的示例：

          ```js
          function* getEmployee() {
              const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];
              const facts = [];

              for (const name of names) {
                  // yield *out* each name AND store the returned data into the facts array
                  facts.push(yield name); 
              }

              return facts;
          }

          const generatorIterator = getEmployee();

          // get the first name out of the generator
          let name = generatorIterator.next().value;
           
          // pass data in *and* get the next name
          name = generatorIterator.next(`${name} is cool!`).value; 

          // pass data in *and* get the next name
          name = generatorIterator.next(`${name} is awesome!`).value; 

          // pass data in *and* get the next name
          name = generatorIterator.next(`${name} is stupendous!`).value; 

          // you get the idea
          name = generatorIterator.next(`${name} is rad!`).value; 
          name = generatorIterator.next(`${name} is impressive!`).value;
          name = generatorIterator.next(`${name} is stunning!`).value;
          name = generatorIterator.next(`${name} is awe-inspiring!`).value;

          // pass the last data in, generator ends and returns the array
          const positions = generatorIterator.next(`${name} is magnificent!`).value; 

          // displays each name with description on its own line
          positions.join('\n'); 
          ```

        instructor_notes: ''
        resources: null
      - id: 374256
        key: f856b968-e773-4a7f-a652-9d8ed8950cc6
        locale: zh-cn
        version: 1.0.0
        title: ''
        semantic_type: RadioQuizAtom
        updated_at: 'Mon Sep 11 2017 16:44:15 GMT+0000 (UTC)'
        is_public: true
        question:
          prompt: |-
            如果运行以下代码，会发生什么？

            ```js
            function* createSundae() {
                const toppings = [];
                
                toppings.push(yield);
                toppings.push(yield);
                toppings.push(yield);
                
                return toppings;
            }

            var it = createSundae();
            it.next('hot fudge');
            it.next('sprinkles');
            it.next('whipped cream');
            it.next();
            ```
          correct_feedback: 因为第一次调用 `.next()` 传入了一些数据。但是该数据没有存储在任何位置。最后一次调用 `.next()` 应该会获得一些数据，因为生成到对 `toppings.push()` 的最后一次调用中。
          video_feedback: null
          default_feedback: |-
            注意，第一次调用 `.next()` 将初始化生成器，将在第一个 `yield` 位置暂停。第二次调用 `.next()` 将向该 `yield` 提供数据。

            数数有多少个 yield，以及每次调用 `.next()` 时，数据是如何被传入的。
          answers:
            - id: a1492837873048
              text: '`toppings` 数组的最后一项将是 `undefined`'
              is_correct: true
              incorrect_feedback: null
            - id: a1492837959516
              text: 将出现错误
              is_correct: false
              incorrect_feedback: null
            - id: a1492838057271
              text: 生成器将被暂停，等待最后一次调用 `.next()`
              is_correct: false
              incorrect_feedback: null
      - id: 374257
        key: 12144750-edfa-4370-a7e9-b8f941211444
        locale: zh-cn
        version: 1.0.0
        title: null
        semantic_type: TextAtom
        updated_at: 'Mon Sep 11 2017 16:44:15 GMT+0000 (UTC)'
        is_public: true
        text: |-
          生成器是强大的新型函数，能够暂停执行代码，同时保持自己的状态。生成器适用于一次一个地循环访问列表项，以便单独处理每项，然后再转到下一项。还可以使用迭代器来处理嵌套回调。例如，假设某个函数需要获得所有仓库的列表和被加星标的次数。在获得每个仓库的星标数量之前，需要获得用户的信息。获得用户的个人资料后，代码可以利用该信息查找所有的仓库。

          生成器还将大量用于 JavaScript 语言未来的新增功能中。一个即将使用生成器的新功能是[异步函数](https://github.com/tc39/ecmascript-asyncawait)。
        instructor_notes: ''
        resources: null
  - id: 374337
    key: 390df346-c727-4a85-9048-e4787fb0b751
    locale: zh-cn
    version: 1.0.0
    title: 第 3 课总结
    semantic_type: Concept
    updated_at: 'Mon Sep 11 2017 16:44:16 GMT+0000 (UTC)'
    is_public: true
    resources: null
    _atoms_ids:
      - 374258
    atoms:
      - id: 374258
        key: a5a6d73b-ee41-4f51-80c0-348823a6bd85
        locale: zh-cn
        version: 1.0.0
        title: 第 3 课总结
        semantic_type: VideoAtom
        updated_at: 'Mon Sep 11 2017 16:44:16 GMT+0000 (UTC)'
        is_public: true
        tags: []
        instructor_notes: ''
        resources: null
        video:
          id: '43144'
          youtube_id: xE4impdnz3c
          subtitles:
            - url: 'https://s3.amazonaws.com/video.udacity-data.com/topher/2016/December/583f7c8a_65-outro/subtitles/lang_en_vs1.srt'
              language_code: en
          transcodings:
            uri_480p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c8a_65-outro/65-outro_480p.mp4'
            uri_480p_1000kbps_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c8a_65-outro/65-outro_480p_1000kbps.mp4'
            uri_480p_ogg: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c8a_65-outro/65-outro_480p.ogg'
            uri_720p_mp4: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c8a_65-outro/65-outro_720p.mp4'
            uri_hls: 'http://video.udacity-data.com.s3.amazonaws.com/topher/2016/December/583f7c8a_65-outro/hls/playlist.m3u8'
